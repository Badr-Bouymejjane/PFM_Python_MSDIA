================================================================================
   EXPLICATION DÃ‰TAILLÃ‰E DU CODE : models/recommender.py
================================================================================

Ce document explique Ã©tape par Ã©tape le fonctionnement du moteur de recommandation
basÃ© sur le contenu (Content-Based Filtering) utilisÃ© dans l'application.

================================================================================
ðŸ“‹ Ã‰TAPE 1 : IMPORTATION DES MODULES & CONFIGURATION (lignes 6-36)
================================================================================

Le code commence par importer les outils nÃ©cessaires pour le traitement de donnÃ©es
et le Machine Learning :

â€¢ BIBLIOTHÃˆQUES DE DONNÃ‰ES :
  - pandas : pour charger et manipuler le fichier CSV des cours
  - numpy : pour les calculs mathÃ©matiques rapides
  - pickle : pour sauvegarder et charger le modÃ¨le entraÃ®nÃ© (Ã©viter de
    rÃ©-entraÃ®ner Ã  chaque dÃ©marrage)

â€¢ BIBLIOTHÃˆQUES DE MACHINE LEARNING (scikit-learn) :
  - TfidfVectorizer : convertit le texte (titres, descriptions) en nombres
    (vecteurs) comprÃ©hensibles par l'ordinateur
  - cosine_similarity : calcule la ressemblance entre deux cours (angle entre
    leurs vecteurs)

â€¢ CONFIGURATION :
  - DATA_PATH : chemin vers le fichier CSV nettoyÃ© ('final_courses_shuffled.csv')
  - ParamÃ¨tres TF-IDF : limite Ã  5000 mots, inclut les expressions de 1 ou 2
    mots (n-grams), ignore les mots trop rares ou trop frÃ©quents

================================================================================
ðŸ”¹ Ã‰TAPE 2 : LA CLASSE CourseRecommender (lignes 39-49)
================================================================================

Une classe unique encapsule toute la logique de recommandation :

â€¢ ATTRIBUTS PRINCIPAUX :
  - self.df : le tableau contenant tous les cours et leurs dÃ©tails
  - self.tfidf_matrix : la reprÃ©sentation mathÃ©matique de tous les cours
  - self.similarity_matrix : la grille gÃ©ante qui stocke la similaritÃ© de
    chaque cours avec tous les autres cours
  - self.is_trained : un drapeau pour savoir si le systÃ¨me est prÃªt Ã  l'emploi

================================================================================
ðŸ”¹ Ã‰TAPE 3 : CHARGEMENT ET NETTOYAGE DES DONNÃ‰ES (lignes 50-110)
================================================================================

La mÃ©thode load_data() prÃ©pare le terrain :

1. LECTURE DU CSV : Essaie de lire le fichier avec une virgule ou un point-virgule
   comme sÃ©parateur (gestion des formats diffÃ©rents).

2. STANDARDISATION : Renomme les colonnes pour avoir des noms cohÃ©rents dans
   toute l'application (ex: 'title_clean' devient 'combined_text', 'partner'
   devient 'instructor').

3. ENRICHISSEMENT :
   - Si la catÃ©gorie manque, elle l'extrait du titre avec des mots-clÃ©s
   - Si le niveau manque, elle cherche "beginner", "advanced" dans les mÃ©tadonnÃ©es
   - Si le prix manque, elle met "Free" par dÃ©faut

Cette Ã©tape est cruciale pour avoir des donnÃ©es propres avant l'analyse.

================================================================================
ðŸ”¹ Ã‰TAPE 4 : PRÃ‰PARATION DU TEXTE (lignes 152-170)
================================================================================

La mÃ©thode prepare_data() crÃ©e la "matiÃ¨re premiÃ¨re" pour l'IA :

â€¢ CRÃ‰ATION DE 'combined_text' :
  L'algorithme ne "lit" pas une seule colonne. Il a besoin de tout le contexte.
  Le code combine donc :
  [TITRE] + [CATÃ‰GORIE] + [NIVEAU] + [INSTRUCTEUR]

  Exemple : "Introduction to Python" + "Programming" + "Beginner" + "IBM"
  = "introduction to python programming beginner ibm"

â€¢ NETTOYAGE : Tout est converti en minuscules pour que "Python" soit identique Ã 
  "python".

================================================================================
ðŸ”¹ Ã‰TAPE 5 : VECTORISATION TF-IDF (lignes 172-192)
================================================================================

La mÃ©thode build_tfidf_matrix() est le cÅ“ur "intelligent" du systÃ¨me :

â€¢ TF-IDF (Term Frequency - Inverse Document Frequency) :
  C'est une technique qui transforme le texte en chiffres en donnant un poids
  Ã  chaque mot.

  - TF (FrÃ©quence) : Plus un mot apparaÃ®t dans un cours, plus il est important.
  - IDF (FrÃ©quence Inverse) : Plus un mot est rare dans l'ensemble des cours,
    plus il a de poids. (Le mot "le" est frÃ©quent mais peu important, le mot
    "neural-network" est rare donc trÃ¨s important).

â€¢ RÃ‰SULTAT :
  Une matrice (tableau gÃ©ant) oÃ¹ chaque ligne est un cours et chaque colonne
  est un mot du vocabulaire.

================================================================================
ðŸ”¹ Ã‰TAPE 6 : CALCUL DE SIMILARITÃ‰ (lignes 194-205)
================================================================================

La mÃ©thode compute_similarity_matrix() compare tous les cours entre eux :

â€¢ SIMILARITÃ‰ COSINUS :
  Calcule l'angle entre les vecteurs de deux cours.
  - 1.0 = Cours identiques (angle 0Â°)
  - 0.0 = Cours totalement diffÃ©rents (angle 90Â°)

â€¢ MATRICE DE SIMILARITÃ‰ :
  Le rÃ©sultat est un tableau carrÃ© (N x N cours). La case [i, j] contient
  le score de ressemblance entre le cours i et le cours j.

================================================================================
ðŸ”¹ Ã‰TAPE 7 : ENTRAÃŽNEMENT GLOBAL (lignes 207-224)
================================================================================

La mÃ©thode train() orchestre tout le processus :
1. Charge les donnÃ©es
2. PrÃ©pare le texte
3. Construit la matrice TF-IDF
4. Calcule la matrice de similaritÃ©

C'est cette mÃ©thode qui est appelÃ©e au dÃ©marrage de l'application si aucun
modÃ¨le n'est sauvegardÃ©.

================================================================================
ðŸ”¹ Ã‰TAPE 8 : RECOMMANDATION PAR SIMILARITÃ‰ (lignes 253-283)
================================================================================

La mÃ©thode recommend_similar(course_id) trouve des cours "frÃ¨res" :

1. Trouve l'index du cours source dans la matrice.
2. RÃ©cupÃ¨re la ligne correspondante dans la matrice de similaritÃ© (qui contient
   les scores avec tous les autres cours).
3. Trie les scores du plus grand au plus petit.
4. Exclut le cours lui-mÃªme (score de 1.0).
5. Retourne les 'n' meilleurs cours avec leur score de similaritÃ© converti en %.

Exemple : Si vous regardez "Python for Data Science", il recommandera
"Data Analysis with Python".

================================================================================
ðŸ”¹ Ã‰TAPE 9 : RECOMMANDATION PAR RECHERCHE (lignes 285-337)
================================================================================

La mÃ©thode recommend_by_query(query) permet de chercher des cours :

1. Transforme la phrase de l'utilisateur (ex: "learn deep learning") en vecteur
   avec le mÃªme vectoriseur TF-IDF.
2. Compare ce vecteur "requÃªte" avec tous les vecteurs "cours".
3. Filtre les rÃ©sultats (optionnel) par plateforme, catÃ©gorie ou niveau.
4. Retourne les cours les plus proches sÃ©mantiquement de la requÃªte.

C'est ce qui permet au moteur de recherche de comprendre le sens, pas juste
les mots exacts.

================================================================================
ðŸ”¹ Ã‰TAPE 10 : FONCTIONS UTILITAIRES (lignes 339-421)
================================================================================

Des fonctions pour faciliter l'affichage dans l'interface web :
- get_course_by_id() : RÃ©cupÃ¨re les dÃ©tails d'un cours
- get_popular_courses() : Retourne les cours les mieux notÃ©s ou avec le meilleur
  score de popularitÃ©
- get_all_courses() : GÃ¨re la pagination et le filtrage pour la page "Courses"
- get_stats() : Fournit des statistiques globales (nombre de cours, catÃ©gories...)

================================================================================
ðŸ”¹ Ã‰TAPE 11 : SAUVEGARDE ET CHARGEMENT (lignes 423-462)
================================================================================

Pour Ã©viter de tout recalculer Ã  chaque redÃ©marrage (ce qui prendrait du temps) :
- save_model() : Enregistre les matrices calculÃ©es dans un fichier 'recommender.pkl'
- load_model() : Recharge ces matrices instantanÃ©ment au dÃ©marrage.

Le code vÃ©rifie aussi la "synchronisation" : si vous ajoutez des cours dans le CSV
mais chargez un vieux modÃ¨le .pkl, il dÃ©tectera l'incohÃ©rence et rÃ©-entraÃ®nera
le modÃ¨le.

================================================================================
ðŸŽ¯ RÃ‰SUMÃ‰ DU FLUX DE DONNÃ‰ES
================================================================================

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  FICHIER CSV     â”‚ (DonnÃ©es brutes)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  NETTOYAGE       â”‚ (Extraction catÃ©gories, minuscules, fusion texte)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  TF-IDF          â”‚ (Conversion Texte -> Nombres)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ MATRICE TF-IDF   â”‚ â”€â”€â”€â–º â”‚ MATRICE SIMILARITÃ‰â”‚ (Relations entre cours)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                         â”‚
         â–¼                         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ RECHERCHE        â”‚      â”‚ RECOMMANDATIONS  â”‚
â”‚ (Query -> Vector)â”‚      â”‚ (Item -> Item)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

================================================================================
ðŸ’¡ POINTS CLÃ‰S Ã€ RETENIR
================================================================================

âœ“ APPROCHE "CONTENT-BASED" : Le systÃ¨me ne nÃ©cessite pas d'historique utilisateur.
  Il recommande basÃ© sur ce que SONT les cours (leur contenu), pas sur ce que
  les autres ont aimÃ©. C'est idÃ©al pour un dÃ©marrage Ã  froid (Cold Start).

âœ“ ANALYSE SÃ‰MANTIQUE : GrÃ¢ce Ã  TF-IDF, le systÃ¨me comprend que "Machine Learning"
  est important et rare, donc il pÃ¨sera plus lourd dans la similaritÃ© que des
  mots communs comme "Introduction".

âœ“ HYBRIDE : L'application web finale mÃ©lange ces scores de similaritÃ© avec
  la note (stars) et la popularitÃ© pour classer les rÃ©sultats, donnant un
  Ã©quilibre entre pertinence et qualitÃ©.

================================================================================
FIN DE L'EXPLICATION
================================================================================
